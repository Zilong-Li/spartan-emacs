;;; -*- lexical-binding: t; no-byte-compile: t; -*-

;; autogenerated by ChatGPT "5 Thinking" (ツ)_/¯

(use-package emacs
  :ensure nil
  :preface
  (defmacro grok--use-pkg-programmatic (&rest specs)
  (declare (indent defun))
  `(progn
     ,@(mapcar
        (lambda (spec)
          (let* ((pkg (if (consp spec) (car spec) spec))
                 (props (if (consp spec) (cdr spec) '()))
                 (pkg-sym
                  (cond
                   ((and (symbolp pkg) (boundp pkg) (symbolp (symbol-value pkg)))
                    (symbol-value pkg))
                   ((symbolp pkg) pkg)
                   (t (error "Invalid package spec: %S" spec))))
                 (ensure (if (plist-member props :ensure)
                             (plist-get props :ensure)
                           t))
                 (ini (plist-get props :init))
                 (cfg (plist-get props :config))
                 (ini-forms (cond
                             ((null ini) nil)
                             ((and (listp ini) (listp (car ini))) ini)
                             (t (list ini))))
                 (cfg-forms (cond
                             ((null cfg) nil)
                             ((and (listp cfg) (listp (car cfg))) cfg)
                             (t (list cfg)))))
            `(use-package ,pkg-sym
               :ensure ,ensure
               ,@(when ini-forms `(:init ,@ini-forms))
               ,@(when cfg-forms `(:config ,@cfg-forms)))))
        specs)))

  (defun grok-insert-eglot-server-programs (table)
    "Insert which eglot servers from TABLE are found on PATH.
TABLE is like `eglot-server-programs'."
    (when (and (boundp table) (symbol-value table))
      (dolist (entry (symbol-value table))
        (let* ((modes (car entry))
               (spec  (cdr entry))
               ;; normalize spec to a list-of-strings command if possible
               (cmd   (cond
                       ;; spec is a string -> wrap in list
                       ((stringp spec) (list spec))
                       ;; spec is a list of strings -> use directly
                       ((and (listp spec)
                             (cl-every #'stringp spec))
                        spec)
                       ;; spec is a dotted pair . <function> -> skip
                       ((and (consp spec)
                             (functionp (cdr spec))) nil)
                       (t spec))))
          (when (and (listp cmd)
                     (stringp (car cmd))
                     (executable-find (car cmd)))
            (insert (format "  %-40s -> %s\n"
                            (if (listp modes) (prin1-to-string modes) (symbol-name modes))
                            (mapconcat #'identity cmd " "))))))))
  (defun grok-insert-eglot-servers ()
    "Insert available Eglot servers from `grok-eglot-autostart-langs`.
Only runs if `grok-eglot-autostart-langs` is bound and non-nil."
    (when (bound-and-true-p grok-eglot-autostart-langs)
      (dolist (pair grok-eglot-autostart-langs)
        (let* ((hook (car pair))
               (spec (cdr pair))
               ;; unwrap (:override "cmd") etc.
               (cmd (cond
                     ((stringp spec) spec)
                     ((and (consp spec) (eq (car spec) :override))
                      (cadr spec))
                     (t nil))))
          (when (and cmd (executable-find cmd))
            (insert (format "  %-22s -> %s\n" hook cmd)))))))

  (defun grok-show-keybinds ()
    "Show Grok Emacs keybinds full-frame; press q to close.
Scans only `grokel` (or ~/.emacs.d/grok.el) for :bind."
    (interactive)
    (let* ((file (if (and (boundp 'grokel) grokel)
                     grokel
                   (expand-file-name "grok.el" user-emacs-directory)))
           (buf  (get-buffer-create "*Grok Keybinds*"))
           rows)
      ;; Parse grok.el, collect (MAP KEY CMD) from :bind only
      (when (and file (file-readable-p file))
        (let* ((content (with-temp-buffer
                          (insert-file-contents file)
                          (buffer-string)))
               (pos 0)
               res obj)
          (while (< pos (length content))
            (setq res (ignore-errors (read-from-string content pos)))
            (if (not res)
                (setq pos (length content))
              (setq obj (car res)
                    pos (cdr res))
              (when (and (consp obj) (eq (car obj) 'use-package))
                ;; Walk the arglist as a stream of keywords; each keyword consumes
                ;; all following non-keyword forms. This way multiple forms under
                ;; :init (etc.) don't break finding :bind.
                (let ((tail (cddr obj)))
                  (while tail
                    (let ((item (car tail)))
                      (setq tail (cdr tail))
                      (when (keywordp item)
                        (let ((kw item) (acc nil))
                          (while (and tail (not (keywordp (car tail))))
                            (push (car tail) acc)
                            (setq tail (cdr tail)))
                          (when (eq kw :bind)
                            (dolist (valform (nreverse acc))
                              (let ((lst (if (and (consp valform)
                                                  (or (stringp (car valform))
                                                      (eq (car valform) :map)
                                                      (consp (car valform))))
                                             valform
                                           (list valform)))
                                    (curm 'global))
                                (while lst
                                  (let ((x (car lst)))
                                    (setq lst (cdr lst))
                                    (cond
                                     ;; Flat plist style: :map MAP
                                     ((eq x :map)
                                      (when lst
                                        (setq curm (car lst))
                                        (setq lst (cdr lst))))
                                     ;; Grouped style: (:map MAP ...bindings...)
                                     ((and (consp x) (eq (car x) :map))
                                      (setq curm (cadr x))
                                      (setq lst (append (cddr x) lst)))
                                     ;; Binding: ("KEY" . cmd) / ("KEY" cmd) / ("KEY" #'cmd) / ("KEY" 'cmd)
                                     ((and (consp x) (stringp (car x)))
                                      (let* ((key (car x))
                                             (rhs (cdr x))
                                             (cmd (cond
                                                   ((symbolp rhs) rhs)
                                                   ((and (consp rhs) (symbolp (car rhs))) (car rhs))
                                                   ((and (consp rhs) (eq (car rhs) 'function)
                                                         (symbolp (cadr rhs))) (cadr rhs))
                                                   ((and (consp rhs) (eq (car rhs) 'quote)
                                                         (symbolp (cadr rhs))) (cadr rhs))
                                                   (t nil))))
                                        (when (and key cmd)
                                          (push (list curm key cmd) rows))))
                                     ;; Nested list -> flatten and continue
                                     ((consp x)
                                      (setq lst (append x lst)))
                                     ;; else ignore
                                     )))))))))))))))

        ;; Render buffer
        (with-current-buffer buf
          (read-only-mode -1)
          (erase-buffer)
          (insert (propertize
         "\nBinds found in grok.el - Use M-x `grok-edit-grok-file' to modify\n\n"
         'face 'success))
          (if rows
              (progn
                (setq rows
                      (sort rows
                            (lambda (a b)
                              (let* ((ma (symbol-name (or (nth 0 a) 'global)))
                                     (mb (symbol-name (or (nth 0 b) 'global)))
                                     (ka (nth 1 a))
                                     (kb (nth 1 b)))
                                (if (string= ma mb)
                                    (string< ka kb)
                                  (string< ma mb))))))
                (let ((curm nil))
                  (dolist (r rows)
                    (let ((m   (or (nth 0 r) 'global))
                          (key (nth 1 r))
                          (cmd (nth 2 r)))
                      (unless (eq m curm)
                        (setq curm m)
                        (insert (format "[%s]\n" (if (eq m 'global) "global" (symbol-name m)))))
                      (insert (format "  %-16s -> %s\n" key cmd))))))
            (insert (format "No :bind forms found in %s\n" file)))
          (insert "\n")
          (when (bound-and-true-p grok-env)
            (when (bound-and-true-p grok-env)
  (insert (concat (propertize "env modifications: " 'face 'success)
                  (format "%S" grok-env))))
            (insert "\n\n")
            (when (getenv "PATH")
  (insert (concat (propertize "PATH: " 'face 'success)
                  (format "%S" (getenv "PATH"))))))
          (when (bound-and-true-p grok-eglot-autostart-langs)
            (insert "\n\n")
            (insert (propertize "LSP servers found on PATH and configured to auto-start:\n"
                    'face 'success))
            (grok-insert-eglot-servers))
          (require 'eglot)
          (when (bound-and-true-p eglot-server-programs)
            (insert "\n")
            (insert (propertize "ALL LSP servers available on PATH:\n"
                    'face 'success))   ;; green-ish, theme-safe
            (grok-insert-eglot-server-programs 'eglot-server-programs))
          ;; (insert (propertize "🧙 Grok Wizardry\n" 'face 'success))
          (goto-char (point-min))
          (special-mode)
          (setq-local header-line-format (propertize "🧙 Grok Diagnostics 🐊✨" 'face 'success)))
        (switch-to-buffer buf)
        (delete-other-windows)))))

(provide 'grok-lib)
